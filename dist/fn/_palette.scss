/// Computes color palette based on a single color. The **name** parameter
/// accepts `red`, `orange`, `yellow`, `lime`, `green`, `teal`, `cyan`, `blue`,
/// `indigo`, `violet`, `fuchsia` or `pink` value. The returned value varies
/// based on provided parameters. If neither **name** or **index** is provided,
/// the function returns map of entire color palette. If **name** is provided,
/// but no **index**, the function returns list of monochrome colors for that
/// specific hue **name**. If **name** and **index** is provided, only that
/// specific color is returned.
/// @access public
/// @param {color|string} $value - Color, or color-key
/// @param {boolean|string} $name [false] - Hue name
/// @param {boolean|number} $index [false] - Index in the monochrome scale
/// @param {number} $tint [1] - Modifier of light colors
/// @param {number} $shade [1] - Modifier of dark colors
/// @param {number} $steps [$const-monochrome-steps] - Number of steps

@function palette(
  $value,
  $name: false,
  $index: false,
  $tint: 1,
  $shade: 1,
  $steps: $const-monochrome-steps
) {
  $color: color($value);
  $palette: ();

  // Properties
  $hue: hue($color);
  $saturation: saturation($color);
  $lightness: lightness($color);

  // Black and gray
  @each $id, $desaturate in ('black': 'black', 'gray': true) {
    $values: ();
    @for $i from 0 to $steps {
      $values: append(
        $values,
        monochrome($color, $i, $tint, $shade, $desaturate)
      );
    }
    $palette: map-merge($palette, (#{$id}: $values));
  }

  // Colors
  @for $i from 1 to length($system-color-names) {
    $base: hsl(($i * 30 + $hue) % 360, $saturation, $lightness);
    $values: ();
    @for $k from 0 to $steps {
      $values: append($values, monochrome($base, $k, $tint, $shade));
    }
    $palette: map-merge($palette, (#{hue-name($base)}: $values));
  }

  // Monochrome
  @if ($name) {
    $palette: map-get($palette, inspect($name));
  }

  // Color
  @if ($index) {
    $palette: nth($palette, $index + 1);
  }

  @return $palette;
}
